
"""
Original script generated by ChatGPT with prompt:

"could you write me a python program that takes a directory as a command line argument.
It opens a json file called ".zattrs" within that directory and reads the JSON.
It looks for a json_data["multiscales"][0]["axes"] item which is a list of dictionaries,
each with a "name". We want the list of axes names to be "t", "c", "z", "y", "x".
If any axes are missing from this list, we need to insert an axis item into the JSON
list, e.g. {"name": "c"}. The list of axes corresponds to directories nested below the
original directory. If we insert an axis at the 2nd index in the list, then we also want
to update the directories on disk, inserting a new directory named "c".
So that updating a list of 4 axes to 5 axes means that we also update directories from
"/t/z/y/x" to "/t/c/z/y/x", moving all the lower directories under the new directory.
"""

import json
import os
import shutil
import sys
from pathlib import Path

REQUIRED_AXES = ["t", "c", "z", "y", "x"]

def read_zattrs(zattrs_path):
    with open(zattrs_path, 'r') as f:
        return json.load(f)

def write_zattrs(zattrs_path, data):
    with open(zattrs_path, 'w') as f:
        json.dump(data, f, indent=2)

def get_axes(data):
    try:
        return data["multiscales"][0]["axes"]
    except (KeyError, IndexError, TypeError):
        raise ValueError("Invalid .zattrs format: missing multiscales[0].axes")

def ensure_axes(axes_list):
    names = [a["name"] for a in axes_list]
    updated = False

    for i, axis in enumerate(REQUIRED_AXES):
        if i >= len(names) or names[i] != axis:
            print(f"Inserting missing axis '{axis}' at position {i}")
            axes_list.insert(i, {"name": axis})
            updated = True
    return axes_list, updated

def update_directory_structure(base_dir, original_axes, new_axes):
    """
    Move directory structure from /t/z/y/x to /t/c/z/y/x
    """
    def recursive_move(current_path, depth):
        if depth >= len(original_axes):
            return
        for entry in os.listdir(current_path):
            full_path = os.path.join(current_path, entry)
            if os.path.isdir(full_path):
                recursive_move(full_path, depth + 1)
                # After recursion, move contents if we inserted an axis here
                if original_axes[depth] != new_axes[depth]:
                    new_path = os.path.join(current_path, entry, "__insert__")
                    os.makedirs(new_path, exist_ok=True)
                    for subentry in os.listdir(full_path):
                        shutil.move(os.path.join(full_path, subentry), new_path)
                    shutil.rmtree(full_path)
                    shutil.move(new_path, os.path.join(current_path, entry, new_axes[depth]))

    recursive_move(base_dir, 0)

def move_data_to_new_structure(base_dir, original_axes, new_axes):
    """
    Moves directories to match new axes order. Assumes axes are only added, not removed or renamed.
    """
    # Build new path by inserting missing axes directories
    def relocate(old_path_parts):
        new_parts = []
        i_old = 0
        for axis in new_axes:
            if i_old < len(original_axes) and axis == original_axes[i_old]:
                new_parts.append(old_path_parts[i_old])
                i_old += 1
            else:
                new_parts.append("0")  # placeholder for new axis
        return new_parts

    for root, dirs, files in os.walk(base_dir, topdown=False):
        rel_path = Path(root).relative_to(base_dir)
        depth = len(rel_path.parts)
        if depth == len(original_axes):
            new_path_parts = relocate(rel_path.parts)
            new_dir = os.path.join(base_dir, *new_path_parts)
            os.makedirs(os.path.dirname(new_dir), exist_ok=True)
            shutil.move(str(root), new_dir)

def main():
    if len(sys.argv) != 2:
        print("Usage: python update_axes.py <directory>")
        sys.exit(1)

    base_dir = Path(sys.argv[1])
    zattrs_path = base_dir / ".zattrs"
    if not zattrs_path.exists():
        print(f"Error: {zattrs_path} does not exist")
        sys.exit(1)

    zattrs = read_zattrs(zattrs_path)
    axes = get_axes(zattrs)

    original_axes = [a["name"] for a in axes]
    axes, updated = ensure_axes(axes)

    if updated:
        print("Axes updated. New axes:", [a["name"] for a in axes])
        zattrs["multiscales"][0]["axes"] = axes
        write_zattrs(zattrs_path, zattrs)
        move_data_to_new_structure(base_dir, original_axes, [a["name"] for a in axes])
    else:
        print("No update needed. Axes already match expected order.")

if __name__ == "__main__":
    main()
